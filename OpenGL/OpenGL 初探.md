# OpenGL 初探

#### 1.图像API简介
`OpenGL`：跨平台变成语言，跨平台的编程图像程序接口，将计算机的资源抽象成一个OpenGL对象，这些资源的操作重新为一个个的OpenGL指令

`OpenGL ES`：是OpenGL三维图像API的子集，针对手机，pad和游戏主机等嵌入式设备而设计，去除许多不必要和性能较低的API接口

`DirectX`：由许多API组成，DirectX并不是一个单纯的图像API，最重要的是DirectX是属于Windows上一个多媒体处理框架，并不支持Windows以外的平台，不是跨平台的框架，可以分为，显示部分、声音部分、输入部分、网络部分

`Metal`：Apple为游戏开发者推出的新的平台技术，该技术能够为3图像提高10倍的渲染性能，是Apple为了解决渲染而推出的框架

####2.图像API目的解决什么问题
1. 简单来说就是实现图形的底层渲染
2. 利用GPU芯片来高效渲染图像
3. API是iOS开发者唯一接近GPU的方式

####3.OpenGL 专业词解析
##### OpenGL上下文[context]，状态机：
1. 在应用程序调用任何OpenGL指令之前，需要首先创建一个OpenGL的上下文，这个上下文是一个非常庞大的状态机，保存了OpenGL中的各种状态，也是OpenGL指令执行的基础
2. OpenGL的函数不管在哪个语言中，都是类似C语一样的面向过程的函数，本质上都是对OpenGL上下文这个庞大的状态机中的某个状态或者对象进行操作，当然首先把这个对象设置为当前的对象，因此通过对OpenGL指令的封装，是可以将OpenGL的线管调用封装成为一个面向对象的图形API的
3. 由于OpanGL上下文是一个巨大的状态机，切换上下文往往会产生较大的开销，但是不同绘制模块可能需要使用完全独立的状态管理，因此，可以在应用程序中分别创建多个不同的上下文，在不同的线程中使用不同的上下文，上下文之间共享纹理，缓冲区等资源，这样的方案，会比反复切换上下文或者大量修改渲染状态更加合理高效

##### 状态机
###### 理论上的状态机
状态机是理论上的一种机器，描述了一个对象在生命周期内所经历的各种状态，状态间的转变，发生转变的动因，条件以及转变中所执行的活动，或者说，状态机是一种行为，说明对象在其生命周期中响应事件所经历的状态序列以及对那些状态事件的响应：

1.有记忆功能，能记住其当前的状态
2.可以接受输入，根据输入的内容和自己的原先状态，修改自己当前状态，并且可以有对应的输入
3.当进入特殊状态(停机状态)的时候，便不在接受输入，停止工作

###### OpenGL里面的状态机
1.OpenGL可以记录自己的状态（比如当前所使用的颜色，是否开启了混合功能）

2.OpenGL可以接受输入（当调用OpenGL函数的时候，实际上考科一看成OpenGL在接受我们的输入），如我们调用glColor31，则OpenGL接受到这个输入后会修改自己的‘当前颜色’这个状态

3.OpenGL可以进行停止状态，不再接受输入，在程序退出前，OpenGL总会先停止工作
#### 4.渲染
将图形/图像数据转换成3D空间图像操作
#### 5.顶点数组和顶点缓冲区
######1.画图一般是先画好骨架，然后再往骨架里面填充颜色，这对与OpenGL也是一样的，顶点数据就是要画的图像的骨架，和现实中不同的是:OpenGL中的图像都是由图元组成的，在OpenGL ES中，有3中类型的图元：点，线，三角形，在那些顶点数据最终存储在哪里呢？开发者可以选择设定的函数指针，再调用绘制方法的时候，直接由内存传入顶点数据，也就是说这部分数据之前是存储在内存当中，被称为顶点数组，而性能更高的做法是提前分配一块显存，将顶点数据预先传入当中，这部分显存，就被成为顶点缓冲区
######2.顶点指的是我们在绘制一个图形时，它的顶点位置数据，而这个数据可以直接存储在数组中或者将其缓存到GPU内存中

#### 6.管线
在OpenGL下渲染图形，就会由经历一个一个节点，而这样的操作可以理解管线，可以抽象成流水线，每个人格类似流水线般执行，管线是个抽象的概念，之所以称之管线，是因为显卡在处理数据的时候是按照一个固定的顺序来的，而且严格按照这个顺序，就像水充一根管子流到另一端，这个顺序不能被打破

#### 7.固定管线/存储着色器
1.在早期的OpenGL版本，它封装了很多着色器程序块内置的一段包含了光照，坐标变换，裁剪等许多功能固定的shader程序来完成，来帮助开发者完成图形的渲染，而开发者只需要传入相应的参数，就能快速完成图形的渲染，类似于iOS开发会封装很多API，只要调用就可以实现功能，不需要关注底层实现原理

2.由于OpenGL的使用场景非常丰富，固定管线或者存储着色起无法完成每个业务，这时将相关部分开发成可编程
	
#### 8.着色器程序Shader
#####概念：

1.OpenGL在处理shader时，和其他编译器一样，通过编译，链接等步骤，生成了着色器程序（glProgram），着色器程序同时包含顶点着色器和片段着色器的运算逻辑，在OpenGL进行绘制的时候，首先有顶点着色器对传入的顶点数据进行运算，再通过图元装配，将顶点装换为图元，然后进行光栅化，将图元这种矢量图形，转化为删格化数据，最后，将删格化数据传入片段着色器进行运算，片段着色器会对删格化数据中的每一个像素进行运算，并决定像素的颜色

2.就全面的将固定渲染管线架构变成了可编程管线，因此，OpenGL在实际调用绘制函数之前，还需要指定一个由shader编程的着色器程序，常见的着色器主要由顶点着色器(VertexShader)，片段着色器(FragmentShader)/像素着色器(PixelShader)，几何着色器(CeometryShader)，曲面细分着色器（TessellationShader），片段着色器和像素着色器只是在OpenGL和DX中的不同叫法而已，可惜的是，
直到OpenGL3.0，依然只支持顶点着色器和片段着色器这两个最基本的着色器
#####具体的着色器：
1.顶点着色器(VertexShader)：

	1.一般用来处理图形每个顶点变化【旋转、平移、投影等】

	2.顶点着色器是OpenGL中用于计算顶点属性的程序，顶点着色器是逐顶点运算的程序，也就是说每个顶点数据都会执行一次顶点着色器，当然这是并行的，并且顶点着色器运行中无法访问其他顶点的数据

	3.一般来说典型的需要计算的顶点属性主要包括坐标变换，逐顶点光照运算等待，顶点坐标由自身坐标装换到归一化坐标系的运算，就是在这里发生的

2.片元/片段/像素着色器(FragmentShader)

	1.一般用来处理图形中每个像素点颜色和填充
	
	2.片段着色器是OpenGL中用于计算片段(像素)颜色的程序，片段着色器逐像素运算的程序，也就是说每个像素都会执行一次片段着色器，且是并行执行
#### 9.GLSL(OpenGL Shading Language)
OpenGL着色器是用来在OpenGL中着色器编程的语言，也是开发人员写的短小的自定义程序，是在图形卡的GPU上执行的，代替了固定的渲染管线的一部分，使渲染管线中不同层次具有可编程性
比如: 视图转换，投影
GLSL的着色器代码分为:Vertex Shader(顶点着色器)和Fragment(片段着色器)

#### 10.光栅化(Rasterzation)
1.是把顶点数据转换为片元的过程，具有将图转化为一个个栅格组成的图像的作用，特点是每个元素对应的缓冲区的一个像素

2.光栅化就是把顶点数据转换为片元的过程，片元中的每个元素对应于帧缓冲区的一个像素

3.光栅化其实是一种将几何图元变成二维图像的过程，
该过程包含了两部分:1.决定窗口坐标中的哪些整型删格化区域被基本图元占用，2.分配一个颜色值和一个深度值到各个区域
光栅化的过程产生的是片元

4.把物体的数学描述以及与物体相关的颜色信息转换为屏幕上用于对应位置的像素以及用于填充像素的颜色，这个过程称为光栅化，这是一个将模拟信号转化为离散信号的过程

####11.纹理
可以理解为图片，在渲染图形时需要在其编码填充图片，为了使场景更加逼真，这里使用图片，就是常说的纹理，在OpenGL中习惯叫纹理，而不是图片

####12.混合(Blending)
在测试阶段之后，如果像素依然没有被剔除，那么像素的颜色将会和帧缓冲区中颜色附着上颜色进行混合，混合的算法可以通过OpenGL的函数进行指定，但是OpenGL提供的混合算法有限，如果需要更加复杂的混合算法，一般可以通过像素着色器进行实现，当然性能会比原生的混合算法要差一些

####13.变换矩阵(Transformation)
图形想发生平移，缩放，旋转变换
####14.投影变换(Projection)
将3D坐标转换为二维屏幕坐标，实际线条也将二维下进行绘制

####15.渲染上屏/交换缓冲区(SwapBuffer)
1.渲染缓冲区一般映射的是系统的资源，例如窗口，如果将图像直接渲染到窗口对应的渲染缓冲区，则可以将图像显示到屏幕上

2.如果每个窗口只有一个缓冲区，那么在绘制的过程中屏幕进行了刷新，窗口可能显示出不完整的图像

3.为了解决上面的问题，常规OpenGL程序至少都会有两个缓冲区，显示在屏幕上的称为屏幕缓冲区，没有显示的称为离屏缓冲区，在一个缓冲区渲染完成后，通过将屏幕缓冲区和离屏缓冲区交换，实现图像在屏幕上的显示

4.由于显示器的刷新一般是逐行进行的，因此为了防止交换缓冲区的时候屏幕上下区域的图像分别属于两个不同的帧，一次交换一般会等待显示器刷新完成的信号，在显示器两次刷新的间隔中进行交换，这个信号被称为垂直同步信号，这个技术被称为垂直同步

5.使用了双缓冲区和垂直同步技术后，由于总是要等待缓冲区交换之后再进行下一帧的渲染，使得帧率无法完全达到硬件允许的最高水平，为了解决这个问题，引入了三缓冲区技术，在等待垂直同步时，来回交替渲染两个离屏的缓冲区，而垂直同步发生时，屏幕缓冲区和最近渲染完成的离屏缓冲区交换，实现充分利用硬件性能的目的
